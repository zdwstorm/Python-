# python笔记-基本的数据类型              <sub> —storm</sub>

## charpter 4  类

类是OOP(面向对象编程)中的重要概念，也是学习Python的一个跨越。

类也是对世界的抽象结果。

### 4.1 基本概念

####  4.1.1 问题空间

问题空间是问题解决者对一个问题所达到的全部认识状态，它是由问题解决者利用问题所包含的信息和已贮存的信息主动构成的。

个问题一般从以下三个方面来定义：

- 初始状态——开始时不完全的信息或令人不满意的状况。
- 目标状态——你希望获得的信息或状态。
- 操作——为了从初始状态迈向目标状态，你可能采取的步骤。

这三个部分加在一起定义了问题空间。

#### 4.1.2 对象

对象（object），是面向对象（Object Oriented）中的术语，既表示客观世界问题空间（Namespace）中的某个具体的事物，又表示软件系统解空间中的基本元素。

Python中的一切都是对象，不管是字符串、函数、模块还是类都是对象，“万物皆对象”。

说明Python中的所有东西都能够进行拼凑组合应用，因为对象就是可以拼凑组合应用的。

- 对象：一个对象有自己的状态、行为和唯一的标识；所有相同类型的对象所具有的结构和行为在它们共同的类中被定义。
- 状态（state）：包括这个对象已有的属性（通常是类里面已经定义好的）和对象具有的当前属性值（这些属性往往是动态的）。
- 行为（behavior）：是指一个对象如何影响外界及被外界影响，表现为对象自身状态的改变和信息的传递。
- 标识（identity）：是指一个对象所具有的区别于所有其他对象的属性（本质上指内存中所创建的对象的地址）。

简化之，对象应该具有属性（就是上面的状态，因为属性更常用）、方法（就是上面的行为，方法常被使用）和标识。因为标识是内存中自动完成的，所以，平时不用怎么管理它，主要就是属性和方。

任何一个对象都要包括这两部分：属性（是什么）和方法（能做什么）。

#### 4.1.3 面向对象

面向对象程序设计（英语：Object-oriented programming，缩写：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例，它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。
面向对象程序设计可以看作是一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反：传统的程序设计主张将程序看作是一系列函数的集合，或者直接就是一系列对电脑下达的指令。面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其他对象，因此它们都可以被看作是一个小型的“机器”，即对象。
目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，支持者声称面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。反对者在某些领域对此予以否认。
当我们提到面向对象的时候，它不仅指一种程序设计方法，更多意义上是一种程序开发方式。在这一方面，我们必须了解更多关于面向对象系统分析和面向对象设计（Object Oriented Design，简称OOD）方面的知识。

#### 4.1.4 类 

在面向对象程序设计中，类（class）是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。

类的更严格的定义是由某种特定的元数据所组成的内聚的包。它描述了一些对象的行为规则，而这些对象就被称为该类的实例。类有接口和结构。接口描述了如何通过方法与类及其实例互操作，而结构描述了一个实例中数据如何划分为多个属性。类是与某个层的对象的最具体的类型。类还可以有运行时表示形式（元对象），它为操作与类相关的元数据提供了运行时支持。
支持类的编程语言在支持与类相关的各种特性方面都多多少少有一些微妙的差。大多数都支持不同形式的类继承。许多语言还支持提供封装性的特性，比如访问修饰符。类的出现，为面向对象编程的三个最重要的特性（封装性、继承性、多态）提供了实现的手段。

#### 4.1.5 编写类

类是对某一群具有同样属性和方法的对象的抽象。

要定义类，就要抽象，找出共同的方面。

****

class 美女：  #用class来声明，后面定义的是一个类

​			pass

****

****

class 美女：

​		胸围=90

​		腰围=58

​		臀围=83

​		皮肤=white

​		唱歌()

​		做饭()

****

上述例子定义了一个名称为“美女”的类，其中约定，没有括号的是属性，有括号的是方法。

`王美女=美女() #类的具体化就是实例`

****

`a=王美女.胸围`

用点号“.”的方式，表示王美女的胸围，得到的变量a就是90。另外，还可以通过这种方式给属性赋值，比如，

`王美女.皮肤=black`

通过实例，也可以访问某个方法，比如，

`王美女.做饭（）`

### 4.2 详解类

#### 4.2.1 新式类和旧式类

>因为Python是一个不断发展的高级语言，导致了在Python 2.x的版本中，有“新式类”和“旧式类（也叫做经典类）”之分。新式类是Python 2.2引进的，在此后的版本中，我们一般用的都是新式类。本着知其然还要知其所以然的目的，简单回顾一下两者的别。

```python
>>>class AA:
    pass
```

这定义了一个非常简单的类，而且是旧式类。

`>>> aa=AA() #将类实例化`

```python
>>> type(AA)
<type 'classobj'>
>>> aa.__class__
<class __main__.AA at 0xb71f017c>
>>> type(aa)
<type 'instance'>
```

解读一下上面的含义。

- type（AA）：查看类AA的类型，返回的是'classobj'。

- aa.__class__：==aa是一个实例，也是一个对象，每个对象都有__class__属性==，用于显示它的类型。这里返回的结果是，从这个结果中可以读出的信息是，aa是类AA的实例，并且类AA在内存中的地址是0xb71f017c。

- type（aa）：是要看实例aa的类型，它显示的结果是instance，意思是告诉我们它的
  类型是一个实例。

  新式类如下：

  ****

  ```python
  >>>class bb(object):
      pass
  >>>B=bb()
  >>>B._class_
  <class '__main__.bb'>
  >>>type(B)
  <class '__main__.bb'>
  ```

  新式类和旧式类还在于两者对于多重继承的查找和调用的方式不同，旧式类是深度优先，新式类是广度优先。

  不管是新式类还是旧式类，都可以通过如下的方法查看它们在内存中的存储空间信息。

  ```python
  >>>print(B)
  <__main__.bb object at 0x00000144A5BF83C8>
  ```

  新式类和旧式类的差别在于类的名字后面要跟上（object），这其实是一种名为“继承”的类的操作，当前的类BB是以类object为上级的（object被称为父类），即BB是继承自类object的新类。在python3中，所有的类自然地都是类object的子类。

  ```python
  >>>class BB(object)： #第一种新式类的定义方法
  	pass
  ```

  第二种定义方法，在类的前面写上：`_metaclass_=type`，然后定义类的时候，就不需要在名字后面写（object）了。

  ```python
  >>>_metaclass_type
  >>>class  CC:
      pass
  >>>cc=CC()
  >>>cc._class_
  <class '__main__.cc'>
  ```

  #### 4.2.2 创建类 

  在一般情况下，一个类不是两三行就能搞定的，所以，下面可能很少使用交互模式了 ，因为那样一旦有一点错误就前功尽弃 了，下面改用编辑页面。

  ****

  class person(object):

  ​	def `__init__`(self,name):

  ​		self.name=name

  ​	def  getName(self):

  ​		return self.name

  ​	def color(self,color):

  ​		print('{} is {}'.format(self.name,color))

  ****

  对上面定义的类进行解释：

  1. 定义类

  class Person，这是在声明创建一个名为“Person”的类。类的名称一般用大写字母开头，这是惯例。如果名称是两个单词，那么两个单词的首字母 都要大写，例如class HotPerson，这种命名方法有一个形象的名字，叫作“驼峰命名”。当然，如果故意不遵循此例，也未尝不可。

  以缩进表示的就是这个类的内容了。其实那些东西看起来并不陌生—就是已经学习过的函数。不过 ，很多程序员喜欢把类里面的函数叫作方法，就是上节中说到的对象的方法。

  函数的命名方法是以def发起，并且函数名称首字母不要用大写，可以使用aa_bb的样式，也可以使用aaBb的样式，一切看你的习惯了。

  ==类中的函数（方法）的参数跟以往的参数样式有区别，那就是每个函数必须包括self函数，并且作为默认的第一个参数，这是需要注意的地方。==至于它的用途，继续学习即可知道。

  2. 初始化

  def_init_这个函数比较特殊，并且有一个名字，叫作初始化函数（注意，很多教材和资料中都把它叫作构造函数）。它是以两个下划线开始，然后以两个下划线结束。
  
  所谓初始化，就是让类有一个基本的面貌。做很多事情都要初始化，让事情有一个具体的起点状态。在类被实例化的时候就执行这个函数，从而将初始化的一些属性可以放到这个函数里面。
  
  此例中的初始化函数就意味着实例化的时候，要给参数name提供一个值，作为类初始化的内容。就是在这个类被实例化的同时，要通过name参数传递一个值，这个值一开始就被写入类和实例中，称为类和实例的一个属性。
  
  `girl=Person('canglaoshi')`

girl就是一个实例对象，它有属性和方法，这里仅说属性，当通过上面的方式实例化后，就自动执行了初始化函数，让实例girl就具有了name属性。

```python
>>>print(girl.name)
```

这就是初始化的功能，简而言之，通过初始化函数，确定了这个实例（类）的“基本属性”。

初始化函数就是一个函数，所以，它的参数设置也符合前面学过的函数参数设置规范。比如：

****

```python
def __init__(self,*args):
    pass
```

------

这种类型的函数*args和前面讲述的函数参数一样，self这个参数是必须要有的。

很多时候，并不是每次都要从外面传入数据，有时候会把初始化函数的某些参数设置默认值，如果没有新的数据传入，就应用 这些默认值。

****

```python
>>>class Person:
    def __init__(self,name,lang='golang',website='www.google.com'):
        self.name=name
        self.lang=lang
        self.website=website
        self.email='1044857432@qq.com'
<<<laoqi=Person('laoqi')
>>>info=Person('qiwsir',lang='python',website='qiweisir.github.io')
>>>print('laoqi.name=',laoqi.name)
>>>print('info.name=',info.name)
>>>print('-'*10)
>>>print('laoqi.lang=',laoqi.lang)
>>>print('-'*10)
>>>print('laoqi.website=',laoqi.website)
>>>print('info.websie',info.website)        
```

运行结果

```python
laoqi.name= LaoQi
info.name= qiwsir
-------
laoqi.lang= golang
info.lang= python
-------
laoqi.website= www.google.com
info.website= qiwsir.github.io
```

在编程界有这样一句话：“类是实例工厂”，什么意思呢？生产物品，比如生产电脑，一个工厂可以生产好多电脑，那么，类就能“生产”好多实例，所以，它是“工厂”。比如上面例子中，就有两个实例。

#### 4.2.3 类中的函数（方法）

这里的‘函数’，指的是类中的那些函数，也把它叫作“方法”。

```
class person(object):

​	def `__init__`(self,name):

​		self.name=name

​	def  getName(self):

​		return self.name

​	def color(self,color):

​		print('{} is {}'.format(self.name,color))
```

构造函数（初始化函数）的后面有两个函数：def .getName(self)和def color(self,color)，这两个函数和前面的初始化函数有共同的地方，都是以self作为第一个参数。

****

```python
>>>def getName(self):
    return self.name
```

****

这个函数的作用就是返回在初始化时得到的值，初始化函数中self.name的值能够在这个函数中被使用，其原因就在于此函数中不可缺少的参数self。

****

```python
>>>girl=Person('canglaoshi')
>>>name=girl.getName()
```

girl.getName()就是调用实例girl的getName()方法（函数）。调用该方法的时候要特别注意，方法名后面的括号必不可少 ，并且括号中不要写参数，在类中的getName(self)函数的第一个参数self是默认的，当实例化之后，调用此函数的时候，第一个参数不需要赋值，那么，变量name的最终结果就是nname='canglaoshi'。

同样道理，对于方法：

****

```python
>>>def color(self,color):
    print('{} is {}'.format(self.name,color))
```

也是在实例化之后调用：

****

```python
>>>girl.color('white')
```

这也是在执行实例化方法，只是由于类中的该方法有两个参数，除了默认的self之外，还有一个color,所以，在调用这个方法的时候，要为后面那个参数传值。

#### 4.2.4 类和实例

- “类提供默认行为，是实例的工厂”，这句话非常经典，一下道破了类和实例的关系。所谓工厂，就是可以用同一个模子做出很多具体的产品，类就是那么模子，实例就是具体的产品。所以，实例是程序处理的实际对象。
- 类由一些语句组成，但是实例通过调用类生成，每次调用这个类，就得到这个类的新的实例。
- 命名类必须用class，例如class Person。class 发起了一个可执行的语句，如果执行，就得到一个 类对象，并且将这个类对象赋值给对象名（比如Person)。

#### 4.2.5 self的作用

类里面的函数，第一个参数就是self，而且不能省略。但是在实例化的时候，这个参数不需要写，也不需要为这个参数传值，似乎就没有这个参数什么事了。

self是一个很神奇的参数。

以前面的类“Persnon"为例，在Person实例化的过程中，girl=Person('canglaoshi')，字符串’canglaoshi‘通过初始化函数（`__init__()`）的参数已经存入到内存中，并且以Person类型的面貌存在，组成了一个对象，这个对象和变量girl建立起引用关系。这个过程也可说成这些数据附加到一个实例上。这样就能够以object.attribute的形式存在，在程序任何地方调用某个对象（数据）。例如上面的程序中以girl.name的方式得到'canglaoshi'。这种调用方式，在类和实例中经常使用，点号“.”后面的称之为类或者实例的属性。

在类内部，就是将所有传入的数据都赋给一个变量，通常这个变量的名字是self。注意，这是习惯，而且是共识，所以，你就不要费尽心思另外取别的名字了。

在初始化函数中的第一个参数self就是起到了这个作用—接收实例化过程中传入的所有数据，这些数据是初始化函数的参数导入的。显然，self应该就是一个实例（准确来说是应用实例），因为它所对应的就是具体数据。。

****

```python
>>>class Person(object):
    def__init__(self,name):
        self.name=name
        print(self)
        print(type(self))
>>>girl=Person('canglaoshi')
<__main__.Person object at 0x0000027209257128> #证实self就是一个实例对象
<class '__main__.Person'>
```

self这个实例跟前面说的那个girl所引用的实例对象一样，也有属性。那么，接下来就规定其属性和属性对应的数据。上面代码中，self.name=name,就是规定了self实例的一个属性，这个属性的名字叫做name，且属性的值等于初始化函数的参数name所导入的数据。注意，self.name中的name和初始化函数的参数name没有任何关系，它们两个一样，只不过是一种巧合。如果，写成self.xya=name也是可以的。

其实，从效果的角度来理解更简化：类的实例girl对应self，girl通过self导入实例属性的所有数据。

当然，self的属性数据，也不一定非得由参数传入，也可以在构造函数中自己设定。

比如：

```python
>>>class Person():
    def_init_(self,name):
        self.name=name
        self.email="1044957332@qq.com" #这个属性不是通过参数传入的 
>>>info=Person("qiwsir")
>>>print("info.name=",'info.name')
>>>print('info.email=','info.email')
```

运行结果

****

```python
info.name= qiwsir
info.email= qiwsir@gmail.com #打印结果
```

这个例子让我们拓展了对self的认识，它不仅仅是为了在类内部传递参数导入的数据，还能在初始化函数中，通过self.attribute的方式，规定self实例对象的属性，这个属也是类实例化对象的属性，即作为类通过初始化函数初始化后所具有的属性。所以在实例info中，通过info.email同样能够得到该属性的数据。在这里，就可以把self形象地理解为“内外兼修”了。或者按照前面所提到的，将info和self对应起来，self主内、info主外。

#### 4.2.6 文档字符串

本书中已经强调过写注释的重要性了，同样，在类里面也要写点东西。

在函数里面，里面可以用三重引号来写说明，在类中也可以，其实在文件开头的部分也能用三重引号写文档字符串说明。这样写的最大好处是能够用help()函数看。

****

```python
'''This is python lesson'''
>>>def start_func(arg):
    '''this is a function'''
    pass
>>>class Myclass:
    '''this is my class'''
    def my_method(self.arg):
        '''this is my method'''
        pass
```

这样的文档不是必需的，当然，在编程中，有不少地方要用"#"符号来做注释。

### 4.3 辨析有关概念 

#### 4.3.1 类属性和实例属性

一个类实例化以后，实例就是一个对象，它有属性。python的类也是一个对象，且也有属性。所以就有了“类属性”和“实例属性”两个属性。

****

```python
>>>class A(object):
    x=7
>>>A.X
7
```

在类A中，变量x所引用的对象，能够直接类调用。或者说x是类A的属性，这就是所谓的“类属性”。类属性仅限于此—类中的变量还有另外的称呼，如静态数据。

****

```python
>>>foo=A()
>>>foo.x
7
```

将类A实例化，通过实例foo也可以得到属性（foo.x），这个属性叫作“实例属性”。

对于同一属性，可以用类来访问（类属性），在一般情况下，也可以通过实例来访问同样的属性。

但有时候它们有区别。相同的地方好理解，关键是区别才是编程中要注意之处。

****

```
>>>foo.x+=1
>>>foo.x
8
>>>A.x
7
```

实例属性（foo.x）更新了，类属性（A.x）没有改变。这至少说明，类属性不会被实例属性左右，也可以进一步说明“类属性与实例属性无关”（这句话不能理解为“类属性”和“实例属性”互不相关，如果要这么理解，按照更严格的逻辑，应该还要看看修改的A.x变化是否影响到foo.x）。

foo.x+=1的本质是实例foo又建立了一个新的属性，但是这个属性（新的foo.x）居然与原来的属性（旧的foo.x）重名，所以，原来的foo.x就被“遮盖”了，只能访问到新的foo.x，它的值是8。既然新的foo.x“遮盖”了旧的foo.x，如果删除它，旧的就会显现出来。

****

```python
>>>foo.x
8
>>>del foo.x
>>>foo.x
7
```

此外，还可以通过建立一个不与旧的实例属性重名的实例属性，理解上述过程。

****

```python
>>>foo.y=foo.x+1
>>>foo.y
8
>>>foo.x
7
```

foo.y就是新建的一个实例属性，它没有影响原来的实例属性foo.x。

前面看到了实例属性不左右类属性，反过来，类属性能否影响实例属性呢？实例就是通过实例化类实现的，按照推理，实例属性应该受到类属性的影响。

```python
>>>A.x+=1
>>>A.x
8
>>>foo.x
8
```

实例属性的值随着类属性的值变化而变化了。

综上，“类属性不受实例属性影响，但实例属性受到类属性左右”，不过，这个结论是有条件的，前面例子中类内的变量应用的是不可变对象（整数）。根据对可变对象和不可变对象的研究经验（可参考浅拷贝和深拷贝），按照保守主义的原则，还应考虑对象是可变对象的情形，因为可变数据能够进行原地修改，这可能会导致不一样。

****

```python
>>>class B(object):
    y=[1,2,3]
>>>B.y
[1,2,3]
>>>bar=B()
>>>bar.y
[1,2,3]
>>>bar.y.append(4)
>>>bar.y
[1,2,3,4]
>>>B.y
[1,2,3,4] #类属性此时也发生了变化
>>>B.y.append('aa')
>>>B.y
[1,2,3,4,'aa']
>>>bar.y
[1,2,3,4,'aa']
```

当类中变量引用的是可变对象时，类属性和实例属性都能直接修改这个对象，从而影响另一方的值。

```python
>>>foo=A()
>>>dir(foo) #实例化A，可以查看其所有的属性
```

增加一个类属性，同时在实例属性中也增加了一样的名称和数据的属性。

```python
>>>A.y='python'
>>>foo.y
'python'
```

反过来，增加实例属性，会不会也增加了一个类属性呢？

```python
>>> foo.z = "python"
>>> foo.z
'python'
>>> A.z
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AttributeError: type object 'A' has no attribute 'z'
```

类并没有收纳通过实例增加的这个属性，这进一步说明，类属性不受实例属性左右。

不管是通过类，还是通过实例，都可以增加和修改属性，其方法就是通过类或者实例的点号操作来实现，即object.attribute，可以实现对属性的修改和增加。

#### 4.3.2  数据流转

在类的应用中，最广泛的是将类实例化，通过实例来执行各种方法（即类里面的函数）。所以，对此过程中的数据流转一定要弄明白。

```python
>>>class Person(object):
    def _init_(self,name):
        self.name=name
    def getName(self):
        return self.name
    def breast(self,n):
        self.breast=n
    def color(self,color):
        print("{} is {}".format(self.name,color))
    def how(self):
        print('{} breast is {}'.format(self.name,self.breast))
>>>girl=Person('canglaoshi')
>>>girl.breast(90)
>>>girl.color('white')
>>>girl.how()
```

运行结果

```python
canglaoshi is white
canglaoshi breast is 90
```

![截图20190522073332](C:\Users\storm\Desktop\截图20190522073332.png)

创建实例girl=Person('canglaoshi')，注意观察图上的箭头方向。girl这个实例和Person类中的self对应，这正是应了上节所概括的“实例变量与self对应，实例变量主外，self主内”的结论。“canglaoshi”是一个具体的数据，通过初始化函数中的name参数，传给selfname，你应已知self也是一个实例，可以为它设置属性，self.name就是一个属性，经过初始化函数，这个属性的值由参数name传入，现在就是“canglaoshi”。

在类person的其他方法中，都是以self为第一个或唯一一个参数。注意，在python中，这个参数要显明写上，在类内部的 函数的参数是不能省略的。这就表示所有python方法都继承self实例对象，它的属性也被带到每个函数中。例如在其他函数里面使用self.name即是调用前面已经确定的实例属性参数。当然，在函数中，还可以继续为实例self增加属性，比如self.breast。这样，通过self实例，就实现了数据在类内部的流转。

如果要把数据从类里面传到外面，可以通过return语句实现。如上述例子中所表示的getName方法。

实例名称girl和self是对应关系，实际上，在类里面也可以用girl代替self。例如，做如下的修改：

```python
>>>class Person(object):
    def _init_(self,name):
        self.name=name
    def getName(self):
       # return self.name
         return girl.name #修改成这样，但是在实际编程实践中不要这么做。
>>>girl=Person('canglaoshi')
>>>name=girl.getName()
>>>print(name)
```

运行结果：

`canglaoshi`

这个例子说明，在实例化之后，实例变量girl和函数里面的self实例是完全对应的。但是，千万不要用上面修改的方式，因为那样写使类没有独立性，这是大忌。